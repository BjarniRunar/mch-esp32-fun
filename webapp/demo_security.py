#
# This file demonstrates some basic web security concepts, and how the
# upagekite library helps navigate them.
#
# WARNING: Some of the examples here are highly insecure! Read carefully!
#
from hashlib import sha256
from upagekite.httpd import url
from upagekite.web import csrf_input, http_require, process_post
try:
    import machine
except:
    machine = None


##[ Helper routines! ]#########################################################

# Storing passwords in the clear is bad!
PW_SALT = 'a crappy salt is better than no salt at all'
def pw_hash(password):
    return sha256(bytes(PW_SALT +(password or '')+ PW_SALT, 'utf-8')).digest()


USER_DATABASE = {
    'root': pw_hash('god')}  # Every hackers' favorite password


def auth_checker(method, data):
    if method != 'basic':
        return False
    username, password = data
    if username not in USER_DATABASE:
        return False
    return (USER_DATABASE[username] == pw_hash(password))


def lan_ip_checker(ip):
    # This is not a complete list, and we could be more precise by
    # checking what our actual local IP is. Fixing this is left as
    # an exercise for the reader!
    if ip.startswith('::ffff:'):
        ip = ip[7:]
    return (
        (ip == '::1') or
        ip.startswith('10.') or
        ip.startswith('127.') or
        ip.startswith('192.168.'))


##[ Web end-points ]##########################################################


# A local-requests-only rebooter, remote requests are rejected.
#
# There is a also a local=True parameter for http_require, but it only
# allows localhost requests, which isn't useful to us.
#
# curl -vX POST http://DEVICE_IP:PORT/reboot.asp
#
# Fun game: Guess your neighbor's IP and reboot their chip!
#
@url('/reboot.asp')
@http_require(methods=['POST'], ip_check=lan_ip_checker)
def web_reboot(request_env):
    if machine is None:
        return {'code': 503, 'msg': 'Unavailable'}
    def reboot():
        machine.reboot()
        request_env['postpone_action'](reboot)
    return {
        'body': '<h1>Rebooting...</h1>',
        'mimetype': 'text/html; charset=utf-8',
        'ttl': 1}


# Generate some useful hacker data, and require a username/password..
#
# curl https://root:god@device.pagekite.me/cvc-list.txt
#
@url('/cvc-list.txt')
@http_require(auth='basic', auth_check=auth_checker)
def web_pins(request_env):
    yield {
        'mimetype': 'text/plain',
        'hdrs': {'Content-Length': '4000'},  # 4 bytes each!
        'ttl': 365 * 24 * 3600}            # Cards expire now and then

    for cvc in range(0, 1000):
        yield '%3.3d\n' % cvc


# This backdoor pretends to want a username and password, but will
# actually accept any username/password pair!
#
# This method also refuses to run unless accessed from localhost or
# over a secure (encrypted, TLS) connection.
#                                                   # %20      == space
#                                                   #      %0a == \n
# curl -vX POST 'https://u:p@HOST/backdoor/?code=import%20gc%0arv=gc.mem_free()'
# curl -vX POST 'https://u:p@HOST/backdoor/?code=rv="%25s"%25(USER_DATABASE,)'
#
@url('/backdoor/')
@http_require(methods=['POST'], auth='basic', secure_transport=True)
def web_pins(request_env):
    glob = globals()
    glob['rv'] = 'Hack me!'

    if 'code' in request_env.query_vars:
        try:
            ## NOTE: This is a terrible idea, please never, ever do this.
            # exec(request_env.query_vars['code'], glob)
            pass
        except Exception as e:
            glob['rv'] = 'ERROR: %s' % e

    return {
        'body': str(glob.get('rv') or 'OK') + '\n',
        'mimetype': 'text/plain; charset=utf-8'}


# This shows our CSRF (cross-site-request-forgery) protection in
# action; a POST will be rejected with a 403 error, unless it includes
# a random token which was generated by visiting the form first.
#
# Just this will fail:
#
# curl -v -d username=a -d password=b https://device.pagekite.me/signup/
#
# But this works:
#
# curl https://device.pagekite.me/signup/
# curl -v -d upk_csrf=CODE -d username=a -d password=b https://...
#
@url('/signup/')
@http_require(methods=['POST', 'GET'], csrf=True)
@process_post(max_bytes=10240)
def web_registration(request_env):
    message = 'Add yourself!'
    try:
        if request_env.http_method == 'POST':
            username = request_env.post_vars['username']
            password = request_env.post_vars['password']
            USER_DATABASE[username] = pw_hash(password)
            message = '<b>Success!</b> Add another?'
    except Exception as e:
        message = 'That failed, please try again.'

    return {
            'mimetype': 'text/html; charset="utf-8"',
            'body': """\
<html><head>
  <title>User Registration Form</title>
</head><body>
  <h2>User Registration Form</h2>
  <p>%s</p>
  <form method=POST>
    Username: <input type=text name=username><br>
    Password: <input type=password name=password><br>
    <!-- Uncomment the following line to let the form work! -->
    <!-- %s -->
    <input type=submit value="Sign me up!">
  </form>
</body></html>
""" % (message, csrf_input(),)}


def setup_security(global_app_env):
    # This adds our kite name / kite secret as login credentials
    if global_app_env['settings'].get('kite_name'):
        username = global_app_env['settings']['kite_name']
        password = global_app_env['settings']['kite_secret']
        USER_DATABASE[username] = pw_hash(password)

    # This would be a good place to figure out the device's actual IP
    # address, and set global variable for the lan_ip_checker to use.
